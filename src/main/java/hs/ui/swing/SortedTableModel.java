package hs.ui.swing;

import hs.util.htree.HTreeList;

import java.text.Collator;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

import javax.swing.SortOrder;
import javax.swing.RowSorter.SortKey;
import javax.swing.event.TableModelEvent;
import javax.swing.event.TableModelListener;
import javax.swing.table.AbstractTableModel;
import javax.swing.table.TableModel;

/**
 * Decorator for {@link TableModel} which adds sorting and filtering 
 * capabilities to the underlying model, without affecting it.  This
 * is accomplished by maintaining a mapping which maps each item in
 * the model to the corresponding location in the view (and vice versa).<p>
 * 
 * This model will register itself as a {@link TableModelListener} to
 * the delegate model and synthesize new events that match the view's
 * order and filtering.  Some events may be altered to a broader scope
 * to ensure consistency between model and view.<p>
 * 
 * For example, an event generated by the model for deleting 10 
 * consecutive rows in the model will be broadened in scope to 
 * encompass all rows, instead of 10 seperate TableModelEvent.DELETE 
 * events.  This is necessary because the view rows are not necessarily 
 * also consecutive, and removing them one  by one would result in an 
 * inconsistent view being presented to any listeners as all 10 rows 
 * were already removed from the underlying model.<p>
 * 
 * The overhead of this model is fairly low, and it is capable of 
 * handling models with a significant number of rows.  This is because 
 * the view is dynamically updated when rows are inserted or deleted.  
 * A full sort is only done when the MAX_ROWS threshold is exceeded.  
 * This implementation relies heavily on the fast 
 * {@link HTreeList#indexOf(Object)} performance of {@link HTreeList}.
 *   
 * @author John Hendrikx
 */
public class SortedTableModel extends AbstractTableModel {
  private static final int MAX_ROWS = 100;
  
  /**
   * List of unique Object instances in (the delegated) model order.  These
   * instances are the same as used in the viewList.
   */
  private final List<Object> modelList = new HTreeList<Object>();
  
  /**
   * List of unique Object instances in view order.  These instances are the 
   * same instances as used in the modelList.  
   */
  private final List<Object> viewList = new HTreeList<Object>();

  /**
   * The underlying model which is used as a delegate when no transformation
   * is applied.
   */
  private final TableModel delegate;

  /**
   * Indicates whether the model has a transformation applied or not.
   */
  private boolean transformed;

  /**
   * Comparators specified by column.
   */
  private Comparator<?>[] comparators;
  
  /**
   * Whether or not to use getStringValueAt. This is indexed by column.
   */
  private boolean[] useToString;
  
  /**
   * Cached SortKeys for the current sort.
   */
  private SortKey[] cachedSortKeys;
  
  /**
   * Cached comparators for the current sort.
   */
  private Comparator<Object>[] sortComparators;
  
  /**
   * The sort keys.
   */
  private List<SortKey> sortKeys = Collections.emptyList();

  public SortedTableModel(TableModel delegate) {
    this.delegate = delegate;
    
    delegate.addTableModelListener(new TableModelListener() {
      @Override
      public void tableChanged(TableModelEvent e) {
        if(e.getType() == TableModelEvent.INSERT) {
          // System.err.println("rowsInserted : " + e.getFirstRow() + "-" + e.getLastRow());
          rowsInserted(e.getFirstRow(), e.getLastRow());
        }
        else if(e.getType() == TableModelEvent.DELETE) {
          // System.err.println("rowsDeleted : " + e.getFirstRow() + "-" + e.getLastRow());
          rowsDeleted(e.getFirstRow(), e.getLastRow());
        }
        else {
          // System.err.println("rowsUpdated : " + e.getFirstRow() + "-" + e.getLastRow());
          rowsUpdated(e.getFirstRow(), e.getLastRow());
        }
      }
    });
  }
    
  @Override
  public int getColumnCount() {
    return delegate.getColumnCount();
  }

  @Override
  public int getRowCount() {
    return delegate.getRowCount();
  }

  @Override
  public Object getValueAt(int rowIndex, int columnIndex) {
    // System.err.println("SortedTableModel: rowIndex = " + rowIndex + "; columnIndex = " + columnIndex + "; viewList.size() = " + viewList.size());
    return delegate.getValueAt(convertRowIndexToModel(rowIndex), columnIndex);
  }
  
  public TableModel getModel() {
    return delegate;
  }
  
  public int convertRowIndexToModel(int index) {
    return index < 0 ? -1 : 
         transformed ? modelList.indexOf(viewList.get(index)) : index;
  }

  public int convertRowIndexToView(int index) {
    return index < 0 ? -1 : 
         transformed ? viewList.indexOf(modelList.get(index)) : index;
  }

  private int insertRow(int modelIndex) {
    Object o = new Object();
    
    modelList.add(modelIndex, o);
    int index = Collections.binarySearch(viewList, o, myComparator);
    
    if(index < 0) {
      index = -1 - index;
    }
    
    viewList.add(index, o);
    
    return index;
  }
   
  private void rowsInserted(int firstRow, int lastRow) {
    if(transformed) {
      // System.err.println("Inserting row " + firstRow);
      if(lastRow - firstRow == 0) {
        int index = insertRow(firstRow);
        fireTableRowsInserted(index, index);
      }
      else {
        if(lastRow - firstRow < MAX_ROWS) {
          for(int i = firstRow; i <= lastRow; i++) {
            insertRow(i);
          }
        }
        else {
          sort();
        }
        
        fireTableDataChanged();
      }
    }
    else {
      System.err.println("Not sorted");
      fireTableRowsInserted(firstRow, lastRow);
    }
  }
  
  private void rowsDeleted(int firstRow, int lastRow) {
    if(transformed) {
      if(lastRow - firstRow == 0) {
        int index = viewList.indexOf(modelList.remove(firstRow));
        
        if(index != -1) {
          viewList.remove(index);
          fireTableRowsDeleted(index, index);
        }
      }
      else {
        if(lastRow - firstRow < MAX_ROWS) {
//        System.out.println("modelList = " + modelList);
//        System.out.println("viewList = " + viewList);
          for(int i = firstRow; i <= lastRow; i++) {
            Object o = modelList.remove(firstRow);
            int index = viewList.indexOf(o);
           // System.err.println("Removing index " + index + " from view for model row " + firstRow + "-" + lastRow + "; o = " + o);
            
            if(index != -1) {
              viewList.remove(index);
            }
          }
        }
        else {
          sort();
        }
        
        fireTableDataChanged();
      }
    }
    else {
      fireTableRowsDeleted(firstRow, lastRow);
    }
  }
  
  private void rowsUpdated(int firstRow, int lastRow) {
    if(firstRow == TableModelEvent.HEADER_ROW) {
      fireTableStructureChanged();
    }
    else {
      if(transformed) {
        if(lastRow - firstRow < MAX_ROWS) {
          for(int i = firstRow; i <= lastRow; i++) {
            int index = viewList.indexOf(modelList.get(i));
            
            if(index != -1) {
              fireTableRowsUpdated(index, index);
            }
          }
        }
        else {
          sort();
          fireTableDataChanged();
        }
      }
      else {
        fireTableRowsUpdated(firstRow, lastRow);
      }
    }
  }
  
  /**
   * Sorts and filters the rows in the view based on the sort keys of the
   * columns currently being sorted and the filter, if any, associated with this
   * sorter. An empty <code>sortKeys</code> list indicates that the view should
   * unsorted, the same as the model.
   * 
   * @see #setRowFilter
   * @see #setSortKeys
   */
  public void sort() {
    updateUseToString();
    if(isUnsorted()) {
      // Unsorted
      transformed = false;
      cachedSortKeys = new SortKey[0];
    }
    else {
      transformed = true;
      cacheSortKeys(getSortKeys());

      modelList.clear();
      viewList.clear();
      
      System.err.println("sort() : adding " + getRowCount() + " rows!");
      
      for(int i = 0; i < getRowCount(); i++) {
        Object o = new Object();
        modelList.add(o);
        viewList.add(o);
      }

      System.err.println("sort() : sorting");

      Collections.sort(viewList, myComparator);
      
      System.err.println("sort() : done");
    }
  }
  
  private boolean isUnsorted() {
    List<? extends SortKey> keys = getSortKeys();
    int keySize = keys.size();
    return(keySize == 0 || keys.get(0).getSortOrder() == SortOrder.UNSORTED);
  }
  
  /**
   * Sets the <code>Comparator</code> to use when sorting the specified column.
   * This does not trigger a sort. If you want to sort after setting the
   * comparator you need to explicitly invoke <code>sort</code>.
   * 
   * @param column
   *          the index of the column the <code>Comparator</code> is to be used
   *          for, in terms of the underlying model
   * @param comparator
   *          the <code>Comparator</code> to use
   * @throws IndexOutOfBoundsException
   *           if <code>column</code> is outside the range of the underlying
   *           model
   */
  public void setComparator(int column, Comparator<?> comparator) {
    checkColumn(column);
    if(comparators == null) {
      comparators = new Comparator[getColumnCount()];
    }
    comparators[column] = comparator;
  }

  /**
   * Returns the <code>Comparator</code> for the specified column. This will
   * return <code>null</code> if a <code>Comparator</code> has not been
   * specified for the column.
   * 
   * @param column
   *          the column to fetch the <code>Comparator</code> for, in terms of
   *          the underlying model
   * @return the <code>Comparator</code> for the specified column
   * @throws IndexOutOfBoundsException
   *           if column is outside the range of the underlying model
   */
  public Comparator<?> getComparator(int column) {
    checkColumn(column);
    if(comparators != null) {
      return comparators[column];
    }
    return null;
  }

  // Returns the Comparator to use during sorting. Where as
  // getComparator() may return null, this will never return null.
  private Comparator<?> getComparator0(int column) {
    Comparator<?> comparator = getComparator(column);
    if(comparator != null) {
      return comparator;
    }
    // This should be ok as useToString(column) should have returned
    // true in this case.
    return Collator.getInstance();
  }
  
  /**
   * Returns the current sort keys. This returns an unmodifiable {@code non-null
   * List}. If you need to change the sort keys, make a copy of the returned
   * {@code List}, mutate the copy and invoke {@code setSortKeys} with the new
   * list.
   * 
   * @return the current sort order
   */
  public List<? extends SortKey> getSortKeys() {
    return sortKeys;
  }
  
  /**
   * Sets the sort keys. This creates a copy of the supplied
   * {@code List}; subsequent changes to the supplied
   * {@code List} do not effect this {@code DefaultRowSorter}.
   * If the sort keys have changed this triggers a sort.
   *
   * @param sortKeys the new <code>SortKeys</code>; <code>null</code>
   *        is a shorthand for specifying an empty list,
   *        indicating that the view should be unsorted
   * @throws IllegalArgumentException if any of the values in
   *         <code>sortKeys</code> are null or have a column index outside
   *         the range of the model
   */
  public void setSortKeys(List<? extends SortKey> sortKeys) {
    List<SortKey> old = this.sortKeys;
    if(sortKeys != null && sortKeys.size() > 0) {
      int max = getColumnCount();
      for(SortKey key : sortKeys) {
        if(key == null || key.getColumn() < 0 || key.getColumn() >= max) {
          throw new IllegalArgumentException("Invalid SortKey");
        }
      }
      this.sortKeys = Collections.unmodifiableList(new ArrayList<SortKey>(sortKeys));
    }
    else {
      this.sortKeys = Collections.emptyList();
    }
    if(!this.sortKeys.equals(old)) {
      sort();
    }
  }

  private void checkColumn(int column) {
    if(column < 0 || column >= getColumnCount()) {
      throw new IndexOutOfBoundsException("column beyond range of TableModel");
    }
  }
  
  private final Comparator<Object> myComparator = new Comparator<Object>() {
    @Override
    public int compare(Object o1, Object o2) {
      int index1 = modelList.indexOf(o1);
      int index2 = modelList.indexOf(o2);
      
      return SortedTableModel.this.compare(index1, index2);
    }
  };
    
  /**
   * Updates the useToString mapping before a sort.
   */
  private void updateUseToString() {
    int i = getColumnCount();
    if(useToString == null || useToString.length != i) {
      useToString = new boolean[i];
    }
    for(--i; i >= 0; i--) {
      useToString[i] = useToString(i);
    }
  }
  
  /**
   * Caches the sort keys before a sort.
   */
  @SuppressWarnings("unchecked")
  private void cacheSortKeys(List<? extends SortKey> keys) {
    int keySize = keys.size();
    sortComparators = new Comparator[keySize];
    for(int i = 0; i < keySize; i++) {
      sortComparators[i] = (Comparator<Object>)getComparator0(keys.get(i).getColumn());
    }
    cachedSortKeys = keys.toArray(new SortKey[keySize]);
  }
  
  /**
   * Returns whether or not to convert the value to a string before doing
   * comparisons when sorting. If true
   * <code>ModelWrapper.getStringValueAt</code> will be used, otherwise
   * <code>ModelWrapper.getValueAt</code> will be used. It is up to subclasses,
   * such as <code>TableRowSorter</code>, to honor this value in their
   * <code>ModelWrapper</code> implementation.
   * 
   * @param column
   *          the index of the column to test, in terms of the underlying model
   * @throws IndexOutOfBoundsException
   *           if <code>column</code> is not valid
   */
  protected boolean useToString(int column) {
    return(getComparator(column) == null);
  }
  
  private int compare(int model1, int model2) {
    int column;
    SortOrder sortOrder;
    Object v1, v2;
    int result;

    for(int counter = 0; counter < cachedSortKeys.length; counter++) {
      column = cachedSortKeys[counter].getColumn();
      sortOrder = cachedSortKeys[counter].getSortOrder();
      if(sortOrder == SortOrder.UNSORTED) {
        result = model1 - model2;
      }
      else {
        // v1 != null && v2 != null
        if(useToString[column]) {
          v1 = getStringValueAt(model1, column);
          v2 = getStringValueAt(model2, column);
        }
        else {
          v1 = delegate.getValueAt(model1, column);
          v2 = delegate.getValueAt(model2, column);
        }
        // Treat nulls as < then non-null
        if(v1 == null) {
          if(v2 == null) {
            result = 0;
          }
          else {
            result = -1;
          }
        }
        else if(v2 == null) {
          result = 1;
        }
        else {
          result = sortComparators[counter].compare(v1, v2);
        }
        if(sortOrder == SortOrder.DESCENDING) {
          result *= -1;
        }
      }
      if(result != 0) {
        return result;
      }
    }
    // If we get here, they're equal. Fallback to model order.
    return model1 - model2;
  }
  
  /**
   * Returns the value as a <code>String</code> at the specified index. This
   * implementation uses <code>toString</code> on the result from
   * <code>getValueAt</code> (making sure to return an empty string for null
   * values). Subclasses that override this method should never return null.
   * 
   * @param row
   *          the row index
   * @param column
   *          the column index
   * @return the value at the specified index as a <code>String</code>
   * @throws IndexOutOfBoundsException
   *           if the indices are outside the range of the model
   */
  private String getStringValueAt(int row, int column) {
    Object o = delegate.getValueAt(row, column);
    if(o == null) {
      return "";
    }
    String string = o.toString();
    if(string == null) {
      return "";
    }
    return string;
  }
  
  @Override
  public String toString() {
    return "modelList = " + modelList.toString() + "; viewList = " + viewList.toString();
  }
}
